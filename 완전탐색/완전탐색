컴퓨터의 계산능력을 이용 

가능한 방법을 전부 만들어 보는 알고리즘 

-> 컴퓨터의 빠른 계산 속도를 이용하는 방법

ex) n개의 원소 중 m개를 고르는 모든 조합 출력


1. Brute Force: for와 if를 이용 ->

1) 완전탐색(브루트 포스) 알고리즘은 모든 경우를 탐색하는 알고리즘이다.
2) 완전탐색(브루트 포스) 알고리즘은 경우의 수에 따라 시간이 증가하기 때문에 시간적인 측면에서 비효율적이다.
3) 완전탐색(브루트 포스) 알고리즘은 만들기 쉽다.
https://jaynamm.tistory.com/entry/%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89-brute-force-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98


2. 비트마스크

비트의 형태 -> 정수의 이진수 표현 활용 


   1        1        0       1       ->     13(10진수) 
1*(2^3)  1*(2^2)  0*(2^1)  1*(2^0)     다더하면 13


1. boolean 배열 -> 메모리 많이 차지 
int[] array1 = [1, 1, 1, 1, 0]; 
int[] array2 = [1, 1, 0, 1, 0]; 
int[] array3 = [1, 0, 1, 0, 0];


2. 비트마스크 -> 정수 통해 나타냄 -> 효울적
{ 0, 1, 2, 3, 4 } => 11111 => (2^4 * 1) + (2^3 * 1) + (2^2 * 1) + (2^1 * 1) + (2^0 * 1) = 31
{ 1, 2, 3, 4 } => 11110 => (2^4 * 1) + (2^3 * 1) + (2^2 * 1) + (2^1 * 1) = 30 
{ 1, 2, 4 } => 10110 => (2^4 * 1) + (2^2 * 1) + (2^1 * 1) = 22
{ 2, 4 } => 10100 => (2^4 * 1) + (2^2 * 1) = 20
{ 1 } => 00010 => (2^1 * 1) = 2


{ 2, 4 } 부분집합에서 i를 추가하고 싶으면,
 단순히 i번째 비트의 값을 1로 변경해주면 된다.

AND (&)
대응하는 두 비트가 모두 1일때 1반환
1010 & 1111 = 1010
A&B
for (int i = 0; i < len; i++) 
{ c[i] = a[i] == 1 && b[i] == 1 ? 1 : 0; }


---------------------------------------------------------------------------
OR 연산(|)
대응하는 하나라도 1일 때, 1을 반환.
1010 | 1111 = 1111
for (int i = 0; i < len; i++) 
{ c[i] = a[i] == 1 || b[i] == 1 ? 1 : 0; }


---------------------------------------------------------------------------
XOR 연산(^)
대응하는 두 비트가 서로 다르면 1을 반환.
1010 | 1111 = 0101
for (int i = 0; i < len; i++) 
{ c[i] = a[i] != b[i] ? 1 : 0; }


---------------------------------------------------------------------------
NOT연산(~)
비트의 값을 반전하여 반환
~1010 = 0101
for (int i = 0; i < len; i++) 
{ c[i] = a[i] == 1 ? 0 : 1; }

----------------------------------------------------------------------------
시프트(Shift) 연산(>>, <<)
왼쪽 또는 오른쪽으로 비트를 옮긴다. 
00001010 << 2 = 101000
00001010 >> 2 = 000010 

왼쪽 쉬프트 ->  A * 2^B
0001 -> 0010 -> 0100 -> 1000 => 1, 2, 4, 8 .....

오른쪽 쉬프트 -> A / 2^B
1000 -> 0100 -> 0010 -> 0001 => 8, 4, 2, 1 ..... 
(A + B) / 2 를 (A + B) >> 1 -> 일반적인 사칙연산 효율적으로 함
---------------------------------------------------------------------------


1010 로 표현하고 있을 때, i번째 비트의 값을 1로 어떻게 변경할 수 있을까? 

1010 | 1 << 2
1010 | 0100 => 1110

시프트 연산을 통해 2번째 비트만 1로 할당되어 있는 이진수를 만든다.
그리고 OR 연산을 통해 원하는 결과를 만들 수 있다.

------------------------------------------------------------------------------

반대로 2 번째 비트의 값을 0로 어떻게 변경할 수 있을까?

1110 & ~1 << 2
1110 & 1011 => 1010

AND 연산과 NOT 연산을 활용할 수 있다.


------------------------------------------------------------------------------

그리고 i번째 비트의 값을 알 수 있는 방법은 다음과 같다.

A & (1 << i)
2번째 비트 - 1010 & (1 << 2) = 1010 & 0100 => 0
3번째 비트 - 1010 & (1 << 3) = 1010 & 1000 => 1000

AND 연산과 시프트 연산을 통해 i번째 비트의 값이 0이라면 값이 0이라는 것을 알 수 있다.

이렇게 비트를 활용한 테크닉을 통해 접근하는 것이 비트마스크인 것이다.




https://mygumi.tistory.com/361

3. 순열



4. 백트래킹

https://thd0011.tistory.com/19

5. BFS