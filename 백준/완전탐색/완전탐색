컴퓨터의 계산능력을 이용 

가능한 방법을 전부 만들어 보는 알고리즘 

-> 컴퓨터의 빠른 계산 속도를 이용하는 방법

ex) n개의 원소 중 m개를 고르는 모든 조합 출력


1. Brute Force: for와 if를 이용 ->

1) 완전탐색(브루트 포스) 알고리즘은 모든 경우를 탐색하는 알고리즘이다.
2) 완전탐색(브루트 포스) 알고리즘은 경우의 수에 따라 시간이 증가하기 때문에 시간적인 측면에서 비효율적이다.
3) 완전탐색(브루트 포스) 알고리즘은 만들기 쉽다.
https://jaynamm.tistory.com/entry/%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89-brute-force-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98


2. 비트마스크

비트의 형태 -> 정수의 이진수 표현 활용 


   1        1        0       1       ->     13(10진수) 
1*(2^3)  1*(2^2)  0*(2^1)  1*(2^0)     다더하면 13


1. boolean 배열 -> 메모리 많이 차지 
int[] array1 = [1, 1, 1, 1, 0]; 
int[] array2 = [1, 1, 0, 1, 0]; 
int[] array3 = [1, 0, 1, 0, 0];


2. 비트마스크 -> 정수 통해 나타냄 -> 효울적
{ 0, 1, 2, 3, 4 } => 11111 => (2^4 * 1) + (2^3 * 1) + (2^2 * 1) + (2^1 * 1) + (2^0 * 1) = 31
{ 1, 2, 3, 4 } => 11110 => (2^4 * 1) + (2^3 * 1) + (2^2 * 1) + (2^1 * 1) = 30 
{ 1, 2, 4 } => 10110 => (2^4 * 1) + (2^2 * 1) + (2^1 * 1) = 22
{ 2, 4 } => 10100 => (2^4 * 1) + (2^2 * 1) = 20
{ 1 } => 00010 => (2^1 * 1) = 2


{ 2, 4 } 부분집합에서 i를 추가하고 싶으면,
 단순히 i번째 비트의 값을 1로 변경해주면 된다.

AND (&)
대응하는 두 비트가 모두 1일때 1반환
1010 & 1111 = 1010
A&B
for (int i = 0; i < len; i++) 
{ c[i] = a[i] == 1 && b[i] == 1 ? 1 : 0; }


---------------------------------------------------------------------------
OR 연산(|)
대응하는 하나라도 1일 때, 1을 반환.
1010 | 1111 = 1111
for (int i = 0; i < len; i++) 
{ c[i] = a[i] == 1 || b[i] == 1 ? 1 : 0; }


---------------------------------------------------------------------------
XOR 연산(^)
대응하는 두 비트가 서로 다르면 1을 반환.
1010 | 1111 = 0101
for (int i = 0; i < len; i++) 
{ c[i] = a[i] != b[i] ? 1 : 0; }


---------------------------------------------------------------------------
NOT연산(~)
비트의 값을 반전하여 반환
~1010 = 0101
for (int i = 0; i < len; i++) 
{ c[i] = a[i] == 1 ? 0 : 1; }

----------------------------------------------------------------------------
시프트(Shift) 연산(>>, <<)
왼쪽 또는 오른쪽으로 비트를 옮긴다. 
00001010 << 2 = 101000
00001010 >> 2 = 000010 

왼쪽 쉬프트 ->  A * 2^B
0001 -> 0010 -> 0100 -> 1000 => 1, 2, 4, 8 .....

오른쪽 쉬프트 -> A / 2^B
1000 -> 0100 -> 0010 -> 0001 => 8, 4, 2, 1 ..... 
(A + B) / 2 를 (A + B) >> 1 -> 일반적인 사칙연산 효율적으로 함
---------------------------------------------------------------------------


1010 로 표현하고 있을 때, i번째 비트의 값을 1로 어떻게 변경할 수 있을까? 

1010 | 1 << 2
1010 | 0100 => 1110

시프트 연산을 통해 2번째 비트만 1로 할당되어 있는 이진수를 만든다.
그리고 OR 연산을 통해 원하는 결과를 만들 수 있다.

------------------------------------------------------------------------------

반대로 2 번째 비트의 값을 0로 어떻게 변경할 수 있을까?

1110 & ~1 << 2
1110 & 1011 => 1010

AND 연산과 NOT 연산을 활용할 수 있다.


------------------------------------------------------------------------------

그리고 i번째 비트의 값을 알 수 있는 방법은 다음과 같다.

A & (1 << i)
2번째 비트 - 1010 & (1 << 2) = 1010 & 0100 => 0
3번째 비트 - 1010 & (1 << 3) = 1010 & 1000 => 1000

AND 연산과 시프트 연산을 통해 i번째 비트의 값이 0이라면 값이 0이라는 것을 알 수 있다.

이렇게 비트를 활용한 테크닉을 통해 접근하는 것이 비트마스크인 것이다.




https://mygumi.tistory.com/361

3. 순열



4. 백트래킹(DFS + 조건문)

어떤 노드 유망성 점검 -> 유망하지 않으면 그 노드의 부모노드로 되돌아감 -> 다른 자손노드 검색

되추적 -> 해답을 찾는과정에서 유망한지 확인 -> 유망하지 않다면 -> 부모노드로 돌아옴
깊이 우선탐색보다 효율이 증가

백트래킹
DFS로 탐색하여 해결 상태에 도달하는데 있어
 불필요한 탐색을 하지 않는 것을 목표로 한다

되추적 -> 스택을 사용 -> 스택에 넣기전 유망성 검사

https://thd0011.tistory.com/19



즉, 백트래킹은 트리 구조를 기반으로 DFS로 깊이 탐색을 진행하면서 각 루트에 대해 조건에 부합하는지 체크(Promising),
만약 해당 트리(나무)에서 조건에 맞지않는 노드는 더 이상 DFS로 깊이 탐색을 진행하지 않고, 가지를 쳐버림 (Pruning)

쉽게 -> DFS + 조건문

#https://pangtrue.tistory.com/71

5. BFS


#https://asung123456.tistory.com/23 -> DFS & BFS 차이



BFS -> 현재 단계 모두 가보고 , 그 다음 단계
DFS -> 갈수있는 끝단계까지 가보고, 다시 한단계씩만 뒤로 돌아와 다음 경우의 수를 찾음


속도,메모리, 구현의 난이도 문제는 있지만

대부분의 경우 DFS로 짠코드는 BFS로도 가능하다.



BFS -> 매 단계마다 가능한 경우의 수를 모두 queue에 저장 -> 메모리 초과
    1. BFS가 최단문제에 적합한 이유
        경우의 수를 모두 queue에 저장하기에 현재 도달한 상태가 최단으로 도달했다는 것이 보장됨
        (단계를 넘어가는 비용이 모두 같다는 전제)
        가봤던 곳을 안가봐도 된다는 뜻 -> 최적의 길찾기

요약) 최단 단계를 구하는 문제하면 BFS


DFS -> 한번에 최대깊이까지만 최대 메모리 사용 -> 그 이상으로 메모리 사용 X
    1. DFS특성상 최단문제 적합 X
        현재 목표 상태에 도달한 것 -> 최단으로 도달했다는 보장 X
        So , 한번 도달했던 상태또한 -> 다음에 수행될 가능성 남겨줌
    
        같은 상태에 도달했더라도 더 빠르게 도달했다면, 갱신, 백트래킹으로 설계필요
    
        알고리즘이 매우 느려지거나, 혹은 언젠가 return된다는 보장이 없다면
    
        dfs의 상태가 순환에 빠지게 될 수도 있다. 
    
        DFS는 언젠간 return될 수 있는 Base가 필요
    
    2. 마지막 방법으로 수학적인 접근으로 DFS -> 최적으로 백트래킹할 수있는 구간잡기
        즉 dfs가 현재 상태가 더 이상 가망이 없다고 판단하면, 더 실행하지 않는 방식이다.

요약) 가야하는 단계가 정해져있거나 일정하고 단계를 모두 완수했을때 
      최적의 값을 찾는다면 DFS!







예시로, 5단계까지 가야 값을 얻어 낼 수 있는 문제가 있고 그중 최적의 경우를 찾는다 하자.

DFS는 처음 5단계까지간 경우의 수에서 값 a를 얻었다.

그 후로는 몇단계까지 가던, a보다 커지는 값은 backtracking을 할 수 있게된다.

 

하지만 BFS는 4단계까지 갔을때 조차 아직 값을 얻어내지 못했고, 모든 경우의 수를 4단계까지 펼치면서 왔기때문에

DFS보다 느릴 가능성이 매우 크다. 

 

